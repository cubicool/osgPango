// -*-c++-*- Copyright (C) 2011 osgPango Development Team
// $Id$

#ifndef OSGPANGO_GLYPHCACHE
#define OSGPANGO_GLYPHCACHE

#include <map>
#include <osg/Geometry>
#include <osg/Texture>
#include <osgCairo/Image>
#include <osgPango/Export>

#include <pango/pangocairo.h>

namespace osgPango {

class Font;
class GlyphRenderer;

struct OSGPANGO_EXPORT CachedGlyph {
	CachedGlyph(
		unsigned int     = 0,
		const osg::Vec2& = osg::Vec2(),
		const osg::Vec2& = osg::Vec2(),
		const osg::Vec2& = osg::Vec2(),
		const osg::Vec2& = osg::Vec2(),
		const osg::Vec2& = osg::Vec2(),
		const osg::Vec2& = osg::Vec2()
	);

	unsigned int img;
	osg::Vec2    origin;
	osg::Vec2    size;
	osg::Vec2    bl;
	osg::Vec2    br;
	osg::Vec2    ur;
	osg::Vec2    ul;
};

// There is one GlyphCache object PER FONT object.
class OSGPANGO_EXPORT GlyphCache: public osg::Referenced {	
public:
	typedef std::map<unsigned int, CachedGlyph>      GlyphMap;
	typedef std::pair<osg::ref_ptr<osgCairo::Image>, 
	                  osg::ref_ptr<osg::Texture> >   CairoAndTexture;
	typedef std::vector<CairoAndTexture>             Images;
	typedef std::vector<Images>                      Layers;

	GlyphCache(GlyphRenderer* = 0, unsigned int = 0, unsigned int = 0);

	const CachedGlyph* getCachedGlyph        (unsigned int);
	const CachedGlyph* createCachedGlyph     (PangoFont*, PangoGlyphInfo*);
	void               writeImagesAsFiles    (const std::string&) const;
	unsigned long      getMemoryUsageInBytes () const;

	osg::Texture* getTexture(unsigned int index, unsigned int layerIndex) {
		return _getTexture(index, layerIndex);
	}
	
	const osg::Texture* getTexture(unsigned int index, unsigned int layerIndex) const {
		return _getTexture(index, layerIndex);
	}

	unsigned int getImageWidth() const {
		return _imgWidth;
	}

	unsigned int getImageHeight() const {
		return _imgHeight;
	}

	const GlyphRenderer* getGlyphRenderer() const {
		return _renderer;
	}

	Layers& getLayers() { 
		return _layers; 
	}
	
	const Layers& getLayers() const {
		return _layers;
	}
	
	GlyphMap& getGlyphMap() {
		return _glyphs;
	}
	
	const GlyphMap& getGlyphMap() const {
		return _glyphs;
	}
	
	void getXYH(double &x, double &y, double &h) const {
		x = _x;
		y = _y;
		h = _h;
	} 
	
	void setXYH(double x, double y, double h) {
		_x = x;
		_y = y;
		_h = h;
	}

private:
	bool _newImageAndTexture();

	void _writeImageVectorFiles(
		const std::string&,
		const std::string&,
		const Images&
	) const;

	osgCairo::Image* _getImage   (unsigned int, unsigned int) const;
	osg::Texture*    _getTexture (unsigned int, unsigned int) const;

	// The "renderer" object, not bound to any local data.
	const GlyphRenderer* _renderer;

	Layers _layers;
	
	// A map of external Pango glyph indexes to their internally CachedGlyph data structures.
	GlyphMap _glyphs;

	double       _x;
	double       _y;
	double       _h;
	unsigned int _imgWidth;
	unsigned int _imgHeight;
};

class OSGPANGO_EXPORT GlyphGeometry: public osg::Geometry {
public:
	GlyphGeometry();

	bool finalize          ();
	bool pushCachedGlyphAt (const CachedGlyph*, const osg::Vec2&);

private:
	unsigned int _numQuads;
};

// We don't use an osg::ref_ptr here becase the Geometry will actually only be temporary.
// The newly allocated osg::Geometry will passed to an osg::Geode during finalize, and
// the Geode will properly dictate when the resources are freed.
typedef std::map<unsigned int, GlyphGeometry*> GlyphGeometryIndex;

}

#endif
