// -*-c++-*- Copyright (C) 2011 osgPango Development Team
// $Id$

#ifndef OSGPANGO_TEXT
#define OSGPANGO_TEXT

#include <pango/pangocairo.h>

#include <osg/AutoTransform>
#include <osg/MatrixTransform>
#include <osgPango/Context>
#include <osgPango/Util>
#include <osgPango/String>

namespace osgPango {

//! This class serves as a lightweight wrapper/container around the various options
//! we can pass to the Pango backend layout manager; things like what effect to use,
//! how much width should be available, etc. Remember, however, that this class only
//! modifies the low-level, Pango-specific aspects of text. Things like changing the
//! font size, face, and color are done dynamically using a special HTML-like
//! markup language embedded within the string itself! :)
class OSGPANGO_EXPORT TextOptions: public osg::Referenced {
public:
	//! These are the various alignment enums for the actual TEXT itself;
	//! they do NOT affect the POSITION of the text physically in the
	//! scene as you may think! That is the job of the derived class,
	//! such as TextTransform.
	enum TextAlignment {
		//! Align all text in the normal, left-to-right style.
		TEXT_ALIGN_LEFT,
		
		//! Align all text by putting each row in the center of
		//! it's permissable width.
		TEXT_ALIGN_CENTER,
		
		//! Align all text by forcing each row to push as far as
		//! is permissable with it's allocated width.
		TEXT_ALIGN_RIGHT,
		
		//! Align each row of text such that the first and last words
		//! of every row fall on the left and right sides of the
		//! allocated width; this is achieved by Pango by adding
		//! additional extraneous space to each true space where required.
		TEXT_ALIGN_JUSTIFY
	};
	
	TextOptions(
		TextAlignment a = TEXT_ALIGN_LEFT,
		int           w = -1,
		int           h = -1,
		int           i = -1,
		int           s = -1
	):
	alignment (a),
	width     (w),
	height    (h),
	indent    (i),
	spacing   (s) {
	}

	bool setupPangoLayout(PangoLayout*) const;

	TextAlignment alignment;
	int           width;
	int           height;
	int           indent;
	int           spacing;
};

//! The Text object is the basic "arrange a group of quad Geometry in the scene according
//! to how Pango instructs us" class. It will satisfy the bulk of you high-quality 2D text
//! needs, especially if you use TextTransform.
class OSGPANGO_EXPORT Text: public ContextDrawable {
public:
	typedef std::pair<GlyphCache*, ColorPair>                 GlyphGeometryMapKey;
	typedef std::map<GlyphGeometryMapKey, GlyphGeometryIndex> GlyphGeometryMap;

	enum ColorMode {
		//! Allow the fgcolor and bgcolor values in Pango markup to overwrite the
		//! first and second indices of the ColorPalette.
		COLOR_MODE_MARKUP_OVERWRITE,

		//! ONLY use the values in the ColorPalette; always ignore the Pango
		//! markup values.
		COLOR_MODE_PALETTE_ONLY
	};
	
	enum CoordinateAlign {
		//! Request pixel-alignment if the scale is an integral value such as 1.0f,
		//! 2.0f, 3.0f, etc; that is to say, there is no remainder when the scale
		//! is divided by the integer cast of itself.
		COORDINATE_ALIGN_AUTO,

		//! Never pixel-align.
		COORDINATE_ALIGN_NONE,

		//! Always pixel-align.
		COORDINATE_ALIGN_ALWAYS
	};

	Text(ColorMode = COLOR_MODE_MARKUP_OVERWRITE);

	virtual ~Text();

	//! This is the method inherited from ContextDrawable; it will be called as a result of:
	//! Context::drawLayout being called with "this" instance.
	virtual void drawGlyphs(PangoFont* font, PangoGlyphString* glyphs, int x, int y);

	// You cannot instaniante Text directly; you need to derive from it and
	// override finalize to actually do something with the _ggMap object
	// internally. A TextTransform object is provided by default.
	virtual bool finalize() = 0;

	virtual void clear();

	void setColorPalette(const ColorPalette&);
	
	//! This version of addText assumes you are using PangoMarkup and does not require
	//! that you pass in a font description. It uses the encoding defined by
	//! OSGPANGO_ENCODING in the osgPango/Export header.
	inline void addText(
		const std::string& str,
		int                x  = 0,
		int                y  = 0,
		const TextOptions& to = TextOptions()
	) {
		addText(OSGPANGO_ENCODING, str, "", x, y, to);
	}

	//! This version of addText does not allow PangoMarkup, and instead requires that
	//! you pass an additional font description string (something like "verdana 100px").
	//! It uses the encoding defined by OSGPANGO_ENCODING.
	inline void addText(
		const std::string& str,
		const std::string& descr,
		int                x  = 0,
		int                y  = 0,
		const TextOptions& to = TextOptions()
	) {
		addText(OSGPANGO_ENCODING, str, descr, x, y, to);
	}

	//! Here you can specify the encoding as the first argument. We do it this way rather
	//! than adding it on as a final option because having to always specify a default
	//! TextOptions() is unwieldy and doesn't always make for the most readable code.
	//! PangoMarkup usage is turned on.
	inline void addText(
		String::Encoding   encoding,
		const std::string& str,
		int                x  = 0,
		int                y  = 0,
		const TextOptions& to = TextOptions()
	) {
		addText(encoding, str, "", x, y, to);
	}

	//! This is the "master" addText method which all others directly call. However,
	//! it's argument list can be unwieldy, so we provide the easier-to-use wrappers above.
	//! Furthermore, this is the version any subclasses should override if they chose
	//! to modify Text behavior.
	virtual void addText(
		String::Encoding,
		const std::string& str,
		const std::string& descr,
		int                x  = 0, 
		int                y  = 0,
		const TextOptions& to = TextOptions()
	);
	
	void setScale(double scale) {
		_scale = scale;
	}

	void setAlpha(float alpha) {
		_alpha = alpha;
	}
	
	void setCoordinateAlign(CoordinateAlign align) {
		_coordinateAlign = align;
	}
	
	float getAlpha() const {
		return _alpha;
	}

	const osg::Vec2& getSize() {
		return _size;
	}

	const osg::Vec2& getSize() const {
		return _size;
	}

	//! The origin of a Text object is actually it's upper-left corner; this happens
	//! due to the way osgPango interfaces with Pango and how Pango renders text from
	//! top-to-bottom and lef-to-right (remember that OpenGL people are the
	//! "oddities" in that we expect origins to be, and align with, the bottom left of
	//! a canvas or rendering surface). In most cases this value won't be of much use
	//! in an OpenGL environment, but since I cannot predict all of the possible uses
	//! of text in an application, here it remains. 
	osg::Vec2 getOrigin() {
		return _origin;
	}

	const osg::Vec2& getOrigin() const {
		return _origin;
	}

	double getScale() const {
		return _scale;
	}

	//! The baseline of a Text object is the bottom-most "line" that text is rendered
	//! on using Pango internally. Similar to getOrigin(), the value returned by
	//! getBaseline() is based on the value derived while interfacing with Pango, and
	//! won't be of much use without a bit of transformation (though this is handled
	//! for you in other Text getter methods).
	unsigned int getBaseline() const {
		return _baseline;
	}

	ColorMode getColorMode() const {
		return _colorMode;
	}
	
	CoordinateAlign getCoordinateAlign() const {
		return _coordinateAlign;
	}

	//! This method differs from getOrigin() in that instead of returning the origin
	//! in Pango space, it returns a 2D vector that you can translate the entire Text
	//! object by in order to align it in OpenGL space to the baseline value.
	osg::Vec2 getOriginBaseline() const;

	//! This method, similar to getOriginBaseline(), returns a translation value
	//! allowing you to align the Text with the furthest, bottom-left coordinate.
	//! This is the most natural alignment point for static text, but is not
	//! reliable for text that will change frequently (like a user input widget).
	//! In those cases, a user should use getOriginBaseline(), so that the
	//! glyphs with parts that render "under" the baseline do not modify the
	//! placement of the Text object too drastically.
	osg::Vec2 getOriginTranslated() const;
	
	void setGlyphRenderer(const std::string& renderer) {
		_glyphRenderer = renderer;
	}
	
	const std::string& getGlyphRenderer() const {
		return _glyphRenderer;
	}

protected:
	bool _finalizeGeometry    (osg::Group* group);
	void _updateOriginAndSize (int x, int y, PangoLayout* layout, const osg::Vec4& extents);
	void _applyTransform      (osg::Node* node, const osg::Matrix& matrix);

	GlyphGeometryMap _ggMap;
	osg::Vec2        _size;
	osg::Vec2        _origin;
	double           _scale;
	int              _baseline;
	float            _alpha;
	bool             _init;
	bool             _finalized;
	std::string      _glyphRenderer;
	ColorMode        _colorMode;
	ColorPalette     _palette;
	osg::Matrix      _lastTransform;
	CoordinateAlign  _coordinateAlign;
};

//! This is a wrapper template class that makes deriving from Text AND combining
//! that object with an OSG object (like MatrixTransform or Billboard) much easier.
//! Using this class isn't strictly necessary, but it does provide a few very
//! valuable services that could become quite cumbersome reimplimenting in
//! every Text-derived object.
template<typename TextClass, typename OSGClass>
class TextOSGInterface: public TextClass, public OSGClass {
public:
	//! These are the alignment enums within TextInterface (not Text itself, since
	//! Text is virtual and has no way of positioning itself) that define how the
	//! text is arranged RELATIVE TO ITS POSITION. They're pretty much
	//! self-explanatory so I won't document each one individually.
	enum PositionAlignment {
		POS_ALIGN_LEFT_TOP,
		POS_ALIGN_LEFT_BOTTOM,
		POS_ALIGN_LEFT_CENTER,
		POS_ALIGN_RIGHT_TOP,
		POS_ALIGN_RIGHT_CENTER,
		POS_ALIGN_RIGHT_BOTTOM,
		POS_ALIGN_CENTER_TOP,
		POS_ALIGN_CENTER_CENTER,
		POS_ALIGN_CENTER_BOTTOM,
		POS_ALIGN_LEFT_BASE_LINE,
		POS_ALIGN_CENTER_BASE_LINE,
		POS_ALIGN_RIGHT_BASE_LINE
	};

	enum AxisAlignment { 
		AXIS_ALIGN_XY_PLANE, 
		AXIS_ALIGN_REVERSED_XY_PLANE, 
		AXIS_ALIGN_XZ_PLANE, 
		AXIS_ALIGN_REVERSED_XZ_PLANE, 
		AXIS_ALIGN_YZ_PLANE, 
		AXIS_ALIGN_REVERSED_YZ_PLANE, 
	};
	
	TextOSGInterface(typename TextClass::ColorMode cm = TextClass::COLOR_MODE_MARKUP_OVERWRITE):
	TextClass          (cm),
	_positionAlignment (POS_ALIGN_LEFT_BOTTOM),
	_axisAlignment     (AXIS_ALIGN_XY_PLANE) {
	}

	//! Necessary override required by Text; it's purpose is to commit
	//! any and all text changes internally and ready the object for display.
	//! If you call addText() dynamically, you will need to also call
	//! finalize() to refresh your changes. This is not true, however,
	//! if you only adjust the position or alignment; as long as the text
	//! doesn't change, there is no need to call finalize().
	virtual bool finalize() {
		if(!TextClass::_finalizeGeometry(this)) return false;
	
		_calculatePosition();
		
		return true;
	}
	
	virtual void clear() {
		TextClass::clear();
		
		OSGClass::removeChild(0, OSGClass::getNumChildren());
	}

	//! Returns the PositionAlignment enum currently in use.
	PositionAlignment getPositionAlignment() const {
		return _positionAlignment;
	}
	
	AxisAlignment getAxisAlignment() const {
		return _axisAlignment; 
	}
	
	//! Sets the PositionAlignment enum to use for modifying the position of
	//! the Text, modifying it's absolute placement. The default PositionAlignment
	//! of POS_ALIGN_LEFT_BOTTOM however is a no-op, since it corresponds to how
	//! Pango arranges the layout by default. The recalculate argument is the
	//! same as for setPosition().
	void setPositionAlignment(PositionAlignment alignment, bool recalculate=true) {
		_positionAlignment = alignment;

		if(recalculate) _calculatePosition();
	}
	
	void setAxisAlignment(AxisAlignment alignment, bool recalculate=true) {
		_axisAlignment = alignment;
		
		if(recalculate) _calculatePosition();
	}
	
	virtual osg::Matrix getAlignmentTransform() const {
		osg::Vec3::value_type s = 1.0f / static_cast<osg::Vec3::value_type>(TextClass::getScale());

		osg::Vec3   origin(TextClass::getOriginTranslated(), 0.0f);
		osg::Vec3   originBaseline(TextClass::getOriginBaseline(), 0.0f);
		osg::Vec3   size(TextClass::getSize(), 0.0f);
		osg::Matrix axisMatrix(osg::Matrix::identity());
		osg::Matrix scaleMatrix(osg::Matrix::scale(osg::Vec3(s, s, 1.0f)));

		if(_positionAlignment == POS_ALIGN_CENTER_BOTTOM) 
			origin.x() -= size.x() / 2.0f
		;

		else if(_positionAlignment == POS_ALIGN_RIGHT_BOTTOM)
			origin.x() -= size.x()
		;

		else if(_positionAlignment == POS_ALIGN_RIGHT_CENTER) origin -= osg::Vec3(
			size.x(),
			size.y() / 2.0f,
			0.0f
		);

		else if(_positionAlignment == POS_ALIGN_RIGHT_TOP)
			origin -= size
		;

		else if(_positionAlignment == POS_ALIGN_CENTER_TOP) origin -= osg::Vec3(
			size.x() / 2.0f,
			size.y(),
			0.0f
		);

		else if(_positionAlignment == POS_ALIGN_LEFT_TOP)
			origin.y() -= size.y()
		;

		else if(_positionAlignment == POS_ALIGN_LEFT_CENTER)
			origin.y() -= size.y() / 2.0f
		;

		else if(_positionAlignment == POS_ALIGN_CENTER_CENTER) origin += osg::Vec3(
			-size.x() / 2.0f,
			-size.y() / 2.0f,
			0.0f
		);

		// TODO: We call origin.set here, but we modify the exisiting origin in
		// the previous calls; why?
		else if(_positionAlignment == POS_ALIGN_LEFT_BASE_LINE) origin.set(
			originBaseline.x(),
			originBaseline.y(),
			0.0f
		);

		else if(_positionAlignment == POS_ALIGN_CENTER_BASE_LINE) origin.set(
			originBaseline.x() - osg::round(size.x() / 2.0f),
			originBaseline.y(),
			0.0f
		);

		else if(_positionAlignment == POS_ALIGN_RIGHT_BASE_LINE) origin.set(
			originBaseline.x() - osg::round(size.x()),
			originBaseline.y(),
			0.0f
		);
 
		origin *= s;
		
		// Handle _axisAlignment...
		if(_axisAlignment == AXIS_ALIGN_XZ_PLANE) axisMatrix = osg::Matrix(
			 1.0f,  0.0f,  0.0f,  0.0f,
			 0.0f,  0.0f,  1.0f,  0.0f,
			 0.0f,  1.0f,  0.0f,  0.0f,
			 0.0f,  0.0f,  0.0f,  1.0f
		);

		else if(_axisAlignment == AXIS_ALIGN_REVERSED_XZ_PLANE) axisMatrix = osg::Matrix(
			-1.0f,  0.0f,  0.0f,  0.0f,
			 0.0f,  0.0f,  1.0f,  0.0f,
			 0.0f,  1.0f,  0.0f,  0.0f,
			 0.0f,  0.0f,  0.0f,  1.0f
		); 

		else if(_axisAlignment == AXIS_ALIGN_YZ_PLANE) axisMatrix = osg::Matrix(
			 0.0f,  1.0f,  0.0f, 0.0f,
			 0.0f,  0.0f,  1.0f, 0.0f,
			 1.0f,  0.0f,  0.0f, 0.0f,
			 0.0f,  0.0f,  0.0f, 1.0f
		);

		else if(_axisAlignment == AXIS_ALIGN_REVERSED_YZ_PLANE) axisMatrix = osg::Matrix(
			 0.0f, -1.0f,  0.0f, 0.0f,
			 0.0f,  0.0f,  1.0f, 0.0f,
			 1.0f,  0.0f,  0.0f, 0.0f,
			 0.0f,  0.0f,  0.0f, 1.0f
		); 

		else if(_axisAlignment == AXIS_ALIGN_REVERSED_XY_PLANE) axisMatrix = osg::Matrix(
			-1.0f,  0.0f,  0.0f, 0.0f,
			 0.0f,  1.0f,  0.0f, 0.0f,
			 0.0f,  0.0f,  1.0f, 0.0f,
			 0.0f,  0.0f,  0.0f, 1.0f
		);
		
		return scaleMatrix * osg::Matrix::translate(origin) * axisMatrix;
	}


protected:
	void _calculatePosition() {
		osg::Matrix alignmentTransform = getAlignmentTransform();

		_applyTransform(this, alignmentTransform);
	}
		
	PositionAlignment _positionAlignment;
	AxisAlignment     _axisAlignment;
};

//! TextTransform is both a useful Text subclass for quick osgPango usage and
//! a small demonstration of how to use TextOSGInterface by gluing
//! the Geometry provided by our parent class with the natural positioning 
//! power of osg::MatrixTransform. It provides a small API for arranging text
//! in 3D space, though it is not at all suited for people who want a full range
//! of transformations (unless they just want to interface with osg::MatrixTransform
//! directly, which is perfectly fine).
typedef TextOSGInterface<Text, osg::MatrixTransform> TextTransform;

}

#endif
