// -*-c++-*- osgPango - Copyright (C) 2010 Jeremy Moles

#ifndef OSGPANGO_TEXT
#define OSGPANGO_TEXT

#include <pango/pangocairo.h>

#include <osg/Geode>
#include <osg/AutoTransform>
#include <osg/MatrixTransform>
#include <osgPango/String>
#include <osgPango/Glyph>

namespace osgPango {

//! An std::pair of OSG color values which we use in a few places as "key" values for
//! differentiating Geometry states based on a foreground AND background (effects)
//! color.
typedef std::pair<osg::Vec3, osg::Vec3> ColorPair;

//! This class serves as a lightweight wrapper/container around the various options
//! we can pass to the Pango backend layout manager; things like what effect to use,
//! how much width should be available, etc. Remember, however, that this class only
//! modifies the low-level, Pango-specific aspects of text. Things like changing the
//! font size, face, and color are done dynamically using a special HTML-like
//! markup language embedded within the string itself! :)
class OSGPANGO_EXPORT TextOptions: public osg::Referenced {
public:
	//! These are the various alignment enums for the actual TEXT itself;
	//! they do NOT affect the POSITION of the text physically in the
	//! scene as you may think! That is the job of the derived class,
	//! such as TextTransform.
	enum TextAlignment {
		//! Align all text in the normal, left-to-right style.
		TEXT_ALIGN_LEFT,
		
		//! Align all text by putting each row in the center of
		//! it's permissable width.
		TEXT_ALIGN_CENTER,
		
		//! Align all text by forcing each row to push as far as
		//! is permissable with it's allocated width.
		TEXT_ALIGN_RIGHT,
		
		//! Align each row of text such that the first and last words
		//! of every row fall on the left and right sides of the
		//! allocated width; this is achieved by Pango by adding
		//! additional extraneous space to each true space where required.
		TEXT_ALIGN_JUSTIFY
	};
	
	TextOptions(
		std::string   r = "",
		TextAlignment a = TEXT_ALIGN_LEFT,
		int           w = -1,
		int           h = -1,
		int           i = -1,
		int           s = -1
	):
	renderer  (r),
	alignment (a),
	width     (w),
	height    (h),
	indent    (i),
	spacing   (s) {
	}

	bool setupPangoLayout(PangoLayout* layout) const;

	std::string   renderer;
	TextAlignment alignment;
	int           width;
	int           height;
	int           indent;
	int           spacing;
};

class OSGPANGO_EXPORT Text: public osg::Referenced {
public:
	typedef std::pair<GlyphCache*, ColorPair>                 GlyphGeometryMapKey;
	typedef std::map<GlyphGeometryMapKey, GlyphGeometryIndex> GlyphGeometryMap;

	Text();

	// You cannot instaniante Text directly; you need to derive from it and
	// override finalize to actually do something with the _ggMap object
	// internally. A TextTransform object is provided by default.
	virtual bool finalize() = 0;

	virtual void clear();

	void drawGlyphs     (PangoFont*, PangoGlyphString*, int, int);
	void addText        (const std::string&, int, int, const TextOptions& = TextOptions());
	void writeAllImages (const std::string&);
	void setAlpha       (double);

	const osg::Vec2& getSize() {
		return _size;
	}

	const osg::Vec2& getSize() const {
		return _size;
	}

	osg::Vec2 getOrigin() {
		return _origin;
	}

	const osg::Vec2& getOrigin() const {
		return _origin;
	}

	unsigned int getBaseline() const {
		return _baseline;
	}

	osg::Vec2 getOriginBaseline   () const;
	osg::Vec2 getOriginTranslated () const;

protected:
	void _finalizeGeometry(GeometryList&);

	GlyphGeometryMap _ggMap;
	osg::Vec2        _size;
	osg::Vec2        _origin;
	int              _lastX;
	int              _lastY;
	int              _baseline;
	double           _alpha;
	bool             _init;
	bool             _newGlyphs;
	std::string      _glyphRenderer;
};

//! This is a wrapper template class that makes deriving from Text much easier.
//! Using this class isn't strictly necessary, but it does provide a few very
//! valuable services that could become quite cumbersome reimplimenting in
//! every Text-derived object.
template<typename T>
class OSGPANGO_EXPORT TextGeodeInterface: public Text, public T {
public:
	TextGeodeInterface() {
		osg::Geode* geode = new osg::Geode();

		geode->setDataVariance(osg::Object::DYNAMIC);

		T::addChild(geode);
		T::setDataVariance(osg::Object::DYNAMIC);
	}

	osg::Geode* getGeode() {
		return dynamic_cast<osg::Geode*>(T::getChild(0));
	}

	const osg::Geode* getGeode() const {
		return dynamic_cast<const osg::Geode*>(T::getChild(0));
	}

	virtual void clear() {
		osg::Geode* geode = getGeode();

		if(geode) geode->removeDrawables(0, geode->getNumDrawables());

		Text::clear();
	}

protected:
	bool _finalizeGeode() {
		osg::Geode* geode = getGeode();

		if(!geode) return false;

		// geode->removeDrawables(0, geode->getNumDrawables());

		GeometryList gl;

		_finalizeGeometry(gl);

		for(GeometryList::iterator i = gl.begin(); i != gl.end(); i++) {
			geode->addDrawable(*i);
		}

		return true;
	}
};

//! TextTransform is both a useful Text subclass for quick osgPango usage and
//! a small demonstration of how to use Text (or technically, TextGeodeInterface,
//! but as we mentioned before it is nothing but a small wrapper class) by gluing
//! the Geometry provided by our parent class with the natural positioning 
//! power of osg::MatrixTransform. It provides a small API for arranging text
//! in 3D space, though it is not at all suited for people who want a full range
//! of transformations (unless they just want to interface with osg::MatrixTransform
//! directly, which is perfectly fine). 
class OSGPANGO_EXPORT TextTransform: public TextGeodeInterface<osg::MatrixTransform> {
public:
	//! These are the alignment enums within TextTransform (not Text itself, since
	//! Text is virtual and has no way of positioning itself) that define how the
	//! text is arranged RELATIVE TO IT'S POSITION. They're pretty much
	//! self-explanatory so I won't document each one individually.
	enum PositionAlignment {
		POS_ALIGN_BOTTOM_LEFT,
		POS_ALIGN_BOTTOM,
		POS_ALIGN_BOTTOM_RIGHT,
		POS_ALIGN_RIGHT,
		POS_ALIGN_TOP_RIGHT,
		POS_ALIGN_TOP,
		POS_ALIGN_TOP_LEFT,
		POS_ALIGN_LEFT,
		POS_ALIGN_CENTER
	};

	TextTransform();

	//! Necessary override required by Text; it's purpose is to commit
	//! any and all text changes internally and ready the object for display.
	//! If you call addText() dynamically, you will need to also call
	//! finalize() to refresh your changes. This is not true, however,
	//! if you only adjust the position or alignment; as long as the text
	//! doesn't change, there is no need to call finalize().
	virtual bool finalize();
	
	//! Returns the non-alignment-adjusted position.
	const osg::Vec3& getPosition() const {
		return _position;
	}

	//! Returns the PositionAlignment enum currently in use.
	PositionAlignment getAlignment() const {
		return _alignment;
	}
	
	//! Sets the position of the MatrixTransform BEFORE any alignment adjustment
	//! should take place. The default final argument is to reposition all the
	//! data internally; if you know you don't need this yet (finalize ALWAYS
	//! recalculates the positions), set it to false.
	void setPosition(const osg::Vec3& position, bool recalculate=true);
	
	//! Sets the PositionAlignment enum to use for modifying the position of
	//! the Text, modifying it's absolute placement. The default PositionAlignment
	//! of POS_ALIGN_BOTTOM_LEFT however is a no-op, since it corresponds to how
	//! Pango arranges the layout by default. The recalculate argument is the
	//! same as for setPosition().
	void setAlignment(PositionAlignment alignment, bool recalculate=true);

protected:
	//! Called internally by setPosition() and setAlignment() to dynamically
	//! adjust the absolute position of the Text. This routine directly 
	//! modifies the data of the parent MatrixTransform class, so users should
	//! be careful if they are ALSO modifying that data.
	void _calculatePosition();

private:
	PositionAlignment _alignment;
	osg::Vec3         _position;
};

class OSGPANGO_EXPORT TextAutoTransform: public TextGeodeInterface<osg::AutoTransform> {
public:
	virtual bool finalize();
};

}

#endif
