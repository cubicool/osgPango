// -*-c++-*- osgPango - Copyright (C) 2009 Jeremy Moles

#ifndef OSGPANGO_TEXT
#define OSGPANGO_TEXT

#include <pango/pangocairo.h>

#include <osg/Geode>
#include <osg/AutoTransform>
#include <osg/MatrixTransform>
#include <osgPango/String>
#include <osgPango/Glyph>

namespace osgPango {

class OSGPANGO_EXPORT TextOptions: public osg::Referenced {
public:
	enum Alignment {
		ALIGN_LEFT,
		ALIGN_CENTER,
		ALIGN_RIGHT,
		ALIGN_JUSTIFY
	};
	
	TextOptions(
		std::string r = "",
		Alignment   a = ALIGN_LEFT,
		int         w = -1,
		int         h = -1,
		int         i = -1,
		int         s = -1
	):
	renderer  (r),
	alignment (a),
	width     (w),
	height    (h),
	indent    (i),
	spacing   (s) {
	}

	bool setupPangoLayout(PangoLayout*) const;

	std::string renderer;
	Alignment   alignment;
	int         width;
	int         height;
	int         indent;
	int         spacing;
};

class OSGPANGO_EXPORT Text: public osg::Referenced {
public:
	typedef std::pair<GlyphCache*, osg::Vec3>                  GlyphGeometryMapKey;
	typedef std::map<GlyphGeometryMapKey, GlyphGeometryVector> GlyphGeometryMap;

	Text();

	// You cannot instaniante Text directly; you need to derive from it and
	// override finalize to actually do something with the _ggMap object
	// internally. A TextTransform object is provided by default.
	virtual bool finalize() = 0;

	void clear          ();
	void drawGlyphs     (PangoFont*, PangoGlyphString*, int, int);
	void addText        (const std::string&, int, int, const TextOptions& = TextOptions());
	void writeAllImages (const std::string&);
	void setAlpha       (double);

	const osg::Vec2& getSize() {
		return _size;
	}

	const osg::Vec2& getSize() const {
		return _size;
	}

	osg::Vec2 getOrigin() {
		return _origin;
	}

	const osg::Vec2& getOrigin() const {
		return _origin;
	}

	unsigned int getBaseline() const {
		return _baseline;
	}

	osg::Vec2 getOriginBaseline   () const;
	osg::Vec2 getOriginTranslated () const;

protected:
	void _finalizeGeometry(GeometryList&);

	GlyphGeometryMap _ggMap;
	osg::Vec2        _size;
	osg::Vec2        _origin;
	int              _lastX;
	int              _lastY;
	int              _baseline;
	double           _alpha;
	bool             _init;
	std::string      _glyphRenderer;
};

// NOTE! Do not worry too much about how this complicated class works. It's main use is to
// glue classes like osg::MatrixTransform and osg::AutoTransform into the osgPango::Text
// interface and make it so that I can easily reuse code...
template<typename T>
class OSGPANGO_EXPORT TextGeodeInterface: public Text, public T {
public:
	TextGeodeInterface() {
		T::addChild(new osg::Geode());
	}

	osg::Geode* getGeode() {
		return dynamic_cast<osg::Geode*>(T::getChild(0));
	}

	const osg::Geode* getGeode() const {
		return dynamic_cast<const osg::Geode*>(T::getChild(0));
	}

protected:
	bool _finalizeGeode() {
		osg::Geode* geode = getGeode();

		if(!geode) return false;

		geode->removeDrawables(0, geode->getNumDrawables());

		GeometryList gl;

		_finalizeGeometry(gl);

		for(GeometryList::iterator i = gl.begin(); i != gl.end(); i++) {
			geode->addDrawable(*i);
		}

		return true;
	}
};

class OSGPANGO_EXPORT TextTransform: public TextGeodeInterface<osg::MatrixTransform> {
public:
	virtual bool finalize();
	
	osg::Vec3 getPosition () const;
	void      setPosition (const osg::Vec2&);
	void      setPosition (const osg::Vec3&);
};

class OSGPANGO_EXPORT TextAutoTransform: public TextGeodeInterface<osg::AutoTransform> {
public:
	virtual bool finalize();
};

}

#endif
